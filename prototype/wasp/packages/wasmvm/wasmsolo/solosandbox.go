// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

package wasmsolo

import (
	"bytes"

	"github.com/iotaledger/wasp/packages/isc"
	"github.com/iotaledger/wasp/packages/kv/dict"
	"github.com/iotaledger/wasp/packages/solo"
	"github.com/iotaledger/wasp/packages/vm/gas"
	"github.com/iotaledger/wasp/packages/wasmvm/wasmhost"
	"github.com/iotaledger/wasp/packages/wasmvm/wasmlib/go/wasmlib"
	"github.com/iotaledger/wasp/packages/wasmvm/wasmlib/go/wasmlib/wasmrequests"
	"github.com/iotaledger/wasp/packages/wasmvm/wasmlib/go/wasmlib/wasmtypes"
)

var cvt wasmhost.WasmConvertor

// SoloSandbox acts as a temporary host side of the WasmLib Sandbox interface.
// It acts as a change-resistant layer to wrap changes to the Solo environment,
// to limit bothering users of WasmLib as little as possible with those changes.
// Note that only those functions that are related to invocation of SC requests
// are actually necessary here. These sandbox functions will never be called
// other than through the SC function call interface generated by schema tool.
type SoloSandbox struct {
	ctx *SoloContext
}

func (s *SoloSandbox) Burn(burnCode gas.BurnCode, par ...uint64) {
	_ = burnCode
	_ = par
	// just do nothing
}

func (s *SoloSandbox) Budget() uint64 {
	panic("implement Budget")
}

func (s *SoloSandbox) Burned() uint64 {
	panic("implement Burned")
}

func (s *SoloSandbox) EstimateGasMode() bool {
	panic("implement GetEstimateGasMode")
}

var (
	_ wasmhost.ISandbox = new(SoloSandbox)
	_ isc.Gas           = new(SoloSandbox)
)

func NewSoloSandbox(ctx *SoloContext) *SoloSandbox {
	s := &SoloSandbox{ctx: ctx}
	return s
}

func (s *SoloSandbox) Call(funcNr int32, args []byte) []byte {
	panic("implement SoloSandbox.Call")
}

func (s *SoloSandbox) checkErr(err error) {
	if err != nil {
		panic(err.Error())
	}
}

func (s *SoloSandbox) Logf(format string, args ...interface{}) {
	s.ctx.Chain.Log().Infof(format, args...)
}

func (s *SoloSandbox) Panicf(format string, args ...interface{}) {
	s.ctx.Chain.Log().Panicf(format, args...)
}

func (s *SoloSandbox) Tracef(format string, args ...interface{}) {
	s.ctx.Chain.Log().Debugf(format, args...)
}

func (s *SoloSandbox) postSync(contract, function string, params dict.Dict, allowance, transfer *isc.Assets) []byte {
	ctx := s.ctx
	req := solo.CallParamsFromDict(contract, function, params)
	if allowance.IsEmpty() {
		allowance = transfer
	}
	req.WithAllowance(allowance)
	// Force a minimum transfer of WasmStorageDeposit base tokens for storage deposit and some gas
	// excess can always be reclaimed from the chain account by the user
	// This also removes the silly requirement to transfer 1 base token
	if transfer.IsEmpty() && !ctx.offLedger {
		transfer = isc.NewAssetsBaseTokens(wasmlib.StorageDeposit)
	}
	if !transfer.IsEmpty() && transfer.BaseTokens < wasmlib.StorageDeposit {
		transfer = transfer.Clone()
		transfer.BaseTokens = wasmlib.StorageDeposit
	}
	req.AddFungibleTokens(transfer)
	if len(transfer.NFTs) != 0 {
		if len(transfer.NFTs) != 1 {
			panic("cannot transfer multiple NFTs")
		}
		nftID := transfer.NFTs[0]
		if ctx.nfts == nil || ctx.nfts[nftID] == nil {
			panic("unknown nftID, did you use the wrong SoloContext?")
		}
		req.WithNFT(ctx.nfts[nftID])
	}
	req.WithMaxAffordableGasBudget()
	var res dict.Dict
	if ctx.offLedger {
		ctx.offLedger = false
		res, ctx.Err = ctx.Chain.PostRequestOffLedger(req, ctx.keyPair)
		ctx.UpdateGasFees()
	} else if !ctx.isRequest {
		ctx.Tx, res, ctx.Err = ctx.Chain.PostRequestSyncTx(req, ctx.keyPair)
		ctx.UpdateGasFees()
	} else {
		ctx.isRequest = false
		ctx.Tx, _, ctx.Err = ctx.Chain.RequestFromParamsToLedger(req, nil)
		if ctx.Err == nil {
			ctx.Chain.Env.EnqueueRequests(ctx.Tx)
		}
		// do NOT ctx.UpdateGasFees(), because this runs in parallel
	}
	if ctx.Err != nil {
		return nil
	}
	return res.Bytes()
}

//////////////////// sandbox functions \\\\\\\\\\\\\\\\\\\\

func (s *SoloSandbox) FnCall(req *wasmrequests.CallRequest) []byte {
	ctx := s.ctx
	ctx.GasFee = 0
	contract := cvt.IscHname(req.Contract)
	if contract != isc.Hn(ctx.scName) {
		s.Panicf("unknown contract: %s vs. %s", contract.String(), ctx.scName)
	}
	function := cvt.IscHname(req.Function)
	funcName := ctx.wc.FunctionFromCode(uint32(function))
	if funcName == "" {
		s.Panicf("unknown function: %s", function.String())
	}
	s.Tracef("CALL %s.%s", ctx.scName, funcName)
	params, err := dict.FromBytes(req.Params)
	s.checkErr(err)
	scAllowance := wasmlib.NewScAssets(req.Allowance)
	if !scAllowance.IsEmpty() {
		allowance := cvt.IscAllowance(scAllowance)
		return s.postSync(ctx.scName, funcName, params, allowance, nil)
	}

	res, err := ctx.Chain.CallView(ctx.scName, funcName, params)
	ctx.Err = err
	if ctx.Err != nil {
		return nil
	}
	return res.Bytes()
}

func (s *SoloSandbox) FnChainID() wasmtypes.ScChainID {
	return s.ctx.CurrentChainID()
}

func (s *SoloSandbox) FnPost(req *wasmrequests.PostRequest) []byte {
	if !bytes.Equal(req.ChainID.Bytes(), s.FnChainID().Bytes()) {
		s.Panicf("unknown chain id: %s", req.ChainID.String())
	}
	contract := cvt.IscHname(req.Contract)
	if contract != isc.Hn(s.ctx.scName) {
		s.Panicf("unknown contract: %s", contract.String())
	}
	function := cvt.IscHname(req.Function)
	funcName := s.ctx.wc.FunctionFromCode(uint32(function))
	if funcName == "" {
		s.Panicf("unknown function: %s", function.String())
	}
	s.Tracef("POST %s.%s", s.ctx.scName, funcName)
	params, err := dict.FromBytes(req.Params)
	s.checkErr(err)
	if req.Delay != 0 {
		s.Panicf("cannot delay solo post")
	}
	allowance := cvt.IscAllowance(wasmlib.NewScAssets(req.Allowance))
	transfer := cvt.IscAllowance(wasmlib.NewScAssets(req.Transfer))
	return s.postSync(s.ctx.scName, funcName, params, allowance, transfer)
}
